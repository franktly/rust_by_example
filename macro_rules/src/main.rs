fn main() {
    macro_base();
    designators();
    overload();
    repeat();
    dsl();
    variadic_interfaces();
}

macro_rules! calcv2{
    // The pattern for a single `eval`
    (eval $e: expr) => {
        {
            let val: usize = $e;
            println!("{} = {}", stringify!{$e}, val);
        }
    };

    // Decompose multiple `eval`s recursively
    (eval $e:expr,  $(eval $es:expr),+) => {
        {
            calcv2! {eval $e}
            calcv2! {$(eval $es),+}
        }};
}

fn variadic_interfaces() {
    calcv2! {
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1,
        eval (6 / 3) + 5
    }
}

fn dsl() {
    macro_rules! calc{
        (eval $e: expr) => {
            {
                let val: usize = $e;
                println!("{} = {}", stringify!{$e}, val);
            }
        };
    }

    calc! {eval 1+2} // `eval` is NOT a Rust keyword
    calc! {eval (1+2) * (3/4)} // `eval` is NOT a Rust keyword
}

// Implement and test `+=`, `*=` and `-=` operators on `Vec<T>`

// Test functions which are generated by `op!` custom macro
use std::ops::{Add, Mul, Sub};

// assert equal length help macro
macro_rules! assert_equal_len {
    // `tt`(token tree) designator is used for operators and tokens
    ($a: expr, $b:expr, $func: ident, $op: tt) => {
        assert!(
            $a.len() == $b.len(),
            "{:?}: dimension mismatch: {:?} {:?} {:?}",
            stringify!($func),
            ($a.len(),),
            stringify!($op),
            ($b.len(),)
        );
    };
}

macro_rules! op {
    ($func: ident, $bound:ident, $op:tt, $method: ident) => {
        fn $func<T: $bound<T, Output = T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
            }
        }
    };
}

op!(my_add, Add, +=, add);
op!(my_mul, Mul, *=, mul);
op!(my_sub, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! my_test {
        ($func: ident, $x: expr, $y: expr, $z: expr) => {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();
                    let y: Vec<_> = iter::repeat($y).take(size).collect();
                    let z: Vec<_> = iter::repeat($z).take(size).collect();
                    super::$func(&mut x, &y);
                    assert_eq!(x, z);
                }
            }
        };
    }

    my_test!(my_add, 1u32, 2u32, 4u32);
    my_test!(my_sub, 8u32, 3u32, 5u32);
    my_test!(my_mul, 2u32, 3u32, 6u32);
}
fn repeat() {
    // match expression
    // calc the minimum of any number of arguments(Resursion)
    macro_rules! find_min {
        // Base case:
        ($x: expr) => ($x);
        // `$x` followed by at least one `$y`
        ($x: expr, $($y:expr), +) => (
            std::cmp::min($x, find_min!($($y),+))
        )
    }

    println!("{}", find_min!(1u32));
    println!("{}", find_min!(1u32 + 2, 2u32));
    println!("{}", find_min!(1u32 + 2, 2u32 * 4, 4u32));
}

// overload
fn overload() {
    // match expression
    macro_rules! test {
        ($left: expr; and $right: expr) => {
            println!(
                "{:?} and {:?} is {:?}",
                stringify!($left),
                stringify!($right),
                $left && $right
            ) // no semicolon and expression NOT statement
        };

        ($left: expr; or $right: expr) => {
            println!(
                "{:?} or {:?} is {:?}",
                stringify!($left),
                stringify!($right),
                $left || $right
            ) // no semicolon
        };
    }

    test!(1i32 + 1 == 2i32; and 2i32 * 3 == 6i32);
    test!(true; or false);
}
// $ name +  (item/block/stmt/pat/expr/ty/ident/path/tt/meta/lifetime/vis/literal)
fn designators() {
    macro_rules! create_function {
        //  This macro takes an argument of designator `ident` and creates a function named
        //  `$func_name`
        //  The `ident` designator is used for variable  or function names
        ($func_name: ident) => {
            fn $func_name() {
                println!("You called {:?}", stringify!($func_name));
            }
        };
    }

    // create the function named `foo` and `bar`
    create_function!(foo);
    create_function!(bar);

    //  This macro takes an argument of designator `expr` and prints it as a string along with
    //  its result
    //  The `expr` designator is used for expressions
    macro_rules! print_result {
        ($expression: expr) => {
            println!("{:?} = {:?}", stringify!($expression), $expression);
        };
    }

    foo();
    bar();

    print_result!(1u32 + 3);
    print_result!({
        let x = 1i32;
        x * x + 2 * x + 1
    });
}

// Metaprogramming
// Ends with `!`
// expanded into abstract syntax trees and don't get unexpected precedence bugs
// 1. DRY: Don't Repeat Yourself, such as assert_eq!
// 2. DSL: Domain-Specific Language, such as Libra Move
// 3. VI: Variadic Interface, such as println!
fn macro_base() {
    macro_rules! say_hello {
        // `()` indicates that the macro takes no argument
        () => {
            // The macro will expand into the contents of this block
            println!("Hello!");
        };
    }

    say_hello!();
    say_hello!();
    say_hello!();
}
